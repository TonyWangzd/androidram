Android内存占用与管理机制探究
1.	Android内存管理机制
安卓系统的架构可以大致分为三层：首先底层是Linux的内核，其次是每一个进程运行时的基础Dalvik虚拟机，每一个进程运行起来如同沙箱一般独立开来，最后是顶层的Application Framework。在系统方面Android在Linux的基础上对移动设备进行了优化，特别是在内存管理机制上：当进程活动停止后，Android不会像我们平常使用的Windows那样将其结束立即从内存释放掉，而是将进程尽可能多的保留在内存中，当用户对此进程第二次打开时，可以直接从内存中调用并提升进程的启动速度。当然，系统内存是有限的，所以当Android被请求需要更多的内存时，Android会调用进程回收机制对内存进行释放。当然，如果用户在进行切换应用的时候，系统不会进行内存交换操作，也就是进程不会立刻被销毁，而是将那些不包含foreground的组件放入LRU Cache中，当用户再切换回应用时可以实现快速恢复。
2.	Android进程回收机制
在探究进程回收机制之前，我了解到Android会根据进程的重要性将进程分为六个层级，当系统内存出现不足时Android系统会按照这个层级对运行的程序进行回收，释放内存。同时为每一个层级定义了一个数值oom_adj，用来表示该进程的重要程度，一般划分区间为0-15,当oom_adj为0时表示此进程目前很重要，用户最不倾向被回收，当其为15时表示系统目前主动倾向于回收这类进程内存。这六个层级分别为：
 FOREGROUND前台进程 oom_adj:0
一般为用户在屏幕上可见的程序进程，同时还包括一些系统进程与电话服务进程

 VISIBLE可见进程 oom_adj:1
应用程序仍然可见，但不是前台进程的应用进程，通常原因为由于某些插件或弹出窗口导致。


 SECONDARY SERVER 次要服务 oom_adj：2
后台运行的包含服务的应用进程是次要服务的主要组成部分。

HIDDEN 后台进程 oom_adj:7
后台进程指不可见且不包含服务但仍然在运行的应用进程。

EMPTY 空进程 oom_adj:15
主要是后台处于挂起状态的应用进程，属于最先被回收的类别。

同时Android还引入了阈值来对应每一个系统优先级，当系统的可用内存低于某一个阈值时，就回收大于该阈值对应的进程优先级的进程。这里Android系统选择维护一张阈值对应表来实现，当然这个表中的数值是可以根据配置与Android版本变化的，以带来最佳的用户体验。
LMK的运行流程如下：ActivityManagerService会对进程评分并与oom_adj进行比较并更新至内核，内核执行LMK进行内存回收。
3.垃圾收集机制（Garbage Collector）
在探究垃圾收集机制之前，我先了解了内存分配机制，在传统的C/C++的malloc分配机制中，当分配一块内存时，通常malloc函数需要遍历一个可用内存空间的链表，采用first-fit（在遍历的过程中返回第一块大于分配请求的地址块）与best-fit（返回大于内存分配请求大小的最小地址块，采用分块算法）。然而以上这两种遍历方式是相当耗时的，在java中当需要为下一个对象分配内存时，只需要移动一个叫做下一个对象的起始位置的指针即可完成操作。所以不同于传统的C/C++等操作系统要求显式释放内存的编程语言中，记得在合适的时候释放内存是一个很有难度的操作，所以JAVA等编程语言提供了基于垃圾回收算法的内存管理机制，同样Android也继承了这种机制。常见的垃圾回收算法有标注并清理，拷贝和逐代回收算法。

标注并清理（mark and sweep GC）
当程序在运行过程中不断的创造新对象导致内存被消耗殆尽，当新的对象创建请求提交时，系统会对其他组件进行挂起并执行GC,这时首先进行标注阶段，即针对GC ROOTS中的每一个对象，采用递归调用的方式遍历其直接或间接引用到的所有对象并进行标注，之后进入清理阶段完成垃圾回收，此时GC线程遍历整个内存，将所有没有标注的对象全部回收，并将保留下来的对象的标注进行清除，以便下次GC过程使用。
这个算法的好处是当内存足够的前提下对程序没有任何额外的性能开支，然而这个算法很大的一个缺点就是在执行垃圾回收过程中，需要中断进程内其他组件的运行，这一点很大程度上造成了用户在使用的过程中卡顿。但是也为后续的算法提供了基础。
拷贝回收算法（copying GC）
	这个算法就是基于标注并清理算法的一个变形，首先将GC的内存堆分为ping和pong两部分，首先在ping区域中完成内存分配请求，就像一开始说的维护一个下对象分配起始位置的指针，操作这个指针完成内存分配，当ping的内存快要用完时，采用标注算法识别出存活的对象，并拷贝到pong区域中然后继续在pong部分中完成后续的内存分配，然后将ping区域中的垃圾进行回收清空，之后依次类推，就像打乒乓球一样。
这种算法的优点很明显，首先内存分配速度快，并且可以实现低中断，但是其缺点也显而易见，那就是在拷贝的过程中占用了额外的内存空间。这些可以在操作系统的虚拟内存提供的地址空间申请实现优化，所以这种算法在一些JVM实现中被广泛应用。
逐代回收算法（Generational GC）
Android Dalvik Heap将堆内存空间划分为三个不同的区域称为对象池，分别为young generation，old generation，permanent generation引入这种方式的原因主要是为了解决标注法中断时间过长，此优化主要是基于如下几个发现：
·大部分对象创建完成后就没用变成垃圾；
·GC过程中收集的对象大部分都是上次GC后创建的，也就是说垃圾进程被反复的创建
·鉴于以上特性可以发现当对象活过一个GC周期后他变成垃圾的概率便非常小因此对其进行反复的标注是浪费时间。
所以可以将逐代回收算法看做是拷贝GC算法的一个扩展一开始在young generation中完成内存的分配请求，当内存即将饱和执行GC标注清理法，存活的对象会移动到old generation当中同样的方式，当old generation快被填满时虚拟机再次执行GC并将存活对象转移至permanent generation。后面新创建的对象仍然在young generation中创建。由于young generation中回收的过程很快，只有少量进程可以存活相反old generation的GC执行不频繁，permanent generation GC执行更少，所以这就实现了很好的平衡。保证了GC执行的高效化。
 
图3-1  根据不同内存数据类型执行不同GC操作
4．内存泄漏（OOM）
Android 中有 Native Heap 和 Dalvik Heap。Android 的 Native Heap 言理论上可分配的空间取决了硬件 RAM，而对于每个进程的 Dalvik Heap 都是有大小限制的，如果应用的内存空间已经接近这个阈值，此时如果再次尝试分配内存的话很容易导致OOM，当然这个阈值也会在不同的设备上因为RAM的大小不同而不同。所以OOM本质实际上就是申请的内存超过了Dalvik Heap的最大值。
内存抖动
内存泄露的一个典型例子就是内存抖动，内存抖动的主要原因是因为内存频繁的分配和释放，这种频繁的GC不仅会导致卡顿，严重时会发生内存泄漏，究其原因还是因为大量的小的对象被频繁的创建，导致出现了内存碎片，从而即便是分配的内存仍然有剩余但是由于这些内存并非连续的所以分配失败导致内存泄漏。
内存泄漏的避免
	经过以上的理解认识到要想避免OOM最重要的一点就是减少进程对象的内存占用，这其中包含使用更加轻量级的数据结构，减少Bitmap的内存占用，还有内存对象的复用，这包括对Android系统自带资源的复用，还主要使用到了对象池技术，在安卓上面最常用的是LRU算法来维护缓存，同样当在一个显示大量图片的控件中，也需要用LRU缓存处理好的Bitmap，以保证内存的利用。同时，在代码实现大量字符串拼接操作时，可以考虑使用StringBuilder来替换“+”，最后尽量不要使用静态变量，因为静态变量会一直占用内存，不会被回收。
5. 位图与优化（Bitmap）
	位图就是指在APP上的大量图片的美化来增加更好的用户体验，这里位图以位图对象来存放在Native Heap中，这时Bitmap的占内存量仅与图像的长宽像素数有关，与原图片的图片格式或压缩比例无关，因此压缩图片质量而不是减少图片尺寸是无法降低该图像所占的内存的。由此引入位图的计算公式：图片长度x图片宽度x一个像素点占用的字节数。
	相比于其他对内存占用，位图可以说是一个大胖子，而且根据Android SDK文档可知Bitmap对象的数据是存放在Native Heap中，这一部分空间是与其他应用程序共享的，所以当考虑性能优化时首先就要考虑如何更好的减少位图的占用空间。
	探究高效加载Bitmap之前，研究了一下如何加载一个Bitmap总结出来加载Bitmap的四种方法分别是decodeFile，decodeResource，decodeStream和decodeByteArray分别用于从文件系统，资源，输入流以及字节数组中加载出一个Bitmap对象，其中使用decodeResource()图片实际上默认情况下是会进行缩放的，在解析时会对根据当前屏幕的Dpi值进行缩放适配操作，使Bitmap与当前设备分辨率相匹配。
	当需要高效加载Bitmap时就需要采用BitmapFactory.Options来加载所需尺寸的图片。这主要是用到了它的inSampleSize参数称为采样率，当inSampleSize()为1时，采样后的图片大小为图片的原始大小，当inSampleSize大于1时，例如2，采样后图片W/L均为原图大小的1/2，像素数即为原图的1/4，故根据计算公式，其占用的内存也为原图大小的1/4，可以发现其缩放比例为原图的1/SamplesSize()的平方。当然inSampleSize必须是大于1的整数，且应该总是2的指数，倘若传入值不为2的指数则系统会选择一个接近值进行替换。同时还可以使用inJustDecodeBounds参数设为true并加载图片。
以上便是我对安卓内存占用的几个方面的研究，有些地方没有研究清楚还望指出
Android内存占用与管理机制探究
1.	Android内存管理机制
安卓系统的架构可以大致分为三层：首先底层是Linux的内核，其次是每一个进程运行时的基础Dalvik虚拟机，每一个进程运行起来如同沙箱一般独立开来，最后是顶层的Application Framework。在系统方面Android在Linux的基础上对移动设备进行了优化，特别是在内存管理机制上：当进程活动停止后，Android不会像我们平常使用的Windows那样将其结束立即从内存释放掉，而是将进程尽可能多的保留在内存中，当用户对此进程第二次打开时，可以直接从内存中调用并提升进程的启动速度。当然，系统内存是有限的，所以当Android被请求需要更多的内存时，Android会调用进程回收机制对内存进行释放。当然，如果用户在进行切换应用的时候，系统不会进行内存交换操作，也就是进程不会立刻被销毁，而是将那些不包含foreground的组件放入LRU Cache中，当用户再切换回应用时可以实现快速恢复。
2.	Android进程回收机制
在探究进程回收机制之前，我了解到Android会根据进程的重要性将进程分为六个层级，当系统内存出现不足时Android系统会按照这个层级对运行的程序进行回收，释放内存。同时为每一个层级定义了一个数值oom_adj，用来表示该进程的重要程度，一般划分区间为0-15,当oom_adj为0时表示此进程目前很重要，用户最不倾向被回收，当其为15时表示系统目前主动倾向于回收这类进程内存。这六个层级分别为：
 FOREGROUND前台进程 oom_adj:0
一般为用户在屏幕上可见的程序进程，同时还包括一些系统进程与电话服务进程

 VISIBLE可见进程 oom_adj:1
应用程序仍然可见，但不是前台进程的应用进程，通常原因为由于某些插件或弹出窗口导致。


 SECONDARY SERVER 次要服务 oom_adj：2
后台运行的包含服务的应用进程是次要服务的主要组成部分。

HIDDEN 后台进程 oom_adj:7
后台进程指不可见且不包含服务但仍然在运行的应用进程。

EMPTY 空进程 oom_adj:15
主要是后台处于挂起状态的应用进程，属于最先被回收的类别。

同时Android还引入了阈值来对应每一个系统优先级，当系统的可用内存低于某一个阈值时，就回收大于该阈值对应的进程优先级的进程。这里Android系统选择维护一张阈值对应表来实现，当然这个表中的数值是可以根据配置与Android版本变化的，以带来最佳的用户体验。
LMK的运行流程如下：ActivityManagerService会对进程评分并与oom_adj进行比较并更新至内核，内核执行LMK进行内存回收。
3.垃圾收集机制（Garbage Collector）
在探究垃圾收集机制之前，我先了解了内存分配机制，在传统的C/C++的malloc分配机制中，当分配一块内存时，通常malloc函数需要遍历一个可用内存空间的链表，采用first-fit（在遍历的过程中返回第一块大于分配请求的地址块）与best-fit（返回大于内存分配请求大小的最小地址块，采用分块算法）。然而以上这两种遍历方式是相当耗时的，在java中当需要为下一个对象分配内存时，只需要移动一个叫做下一个对象的起始位置的指针即可完成操作。所以不同于传统的C/C++等操作系统要求显式释放内存的编程语言中，记得在合适的时候释放内存是一个很有难度的操作，所以JAVA等编程语言提供了基于垃圾回收算法的内存管理机制，同样Android也继承了这种机制。常见的垃圾回收算法有标注并清理，拷贝和逐代回收算法。

标注并清理（mark and sweep GC）
当程序在运行过程中不断的创造新对象导致内存被消耗殆尽，当新的对象创建请求提交时，系统会对其他组件进行挂起并执行GC,这时首先进行标注阶段，即针对GC ROOTS中的每一个对象，采用递归调用的方式遍历其直接或间接引用到的所有对象并进行标注，之后进入清理阶段完成垃圾回收，此时GC线程遍历整个内存，将所有没有标注的对象全部回收，并将保留下来的对象的标注进行清除，以便下次GC过程使用。
这个算法的好处是当内存足够的前提下对程序没有任何额外的性能开支，然而这个算法很大的一个缺点就是在执行垃圾回收过程中，需要中断进程内其他组件的运行，这一点很大程度上造成了用户在使用的过程中卡顿。但是也为后续的算法提供了基础。
拷贝回收算法（copying GC）
	这个算法就是基于标注并清理算法的一个变形，首先将GC的内存堆分为ping和pong两部分，首先在ping区域中完成内存分配请求，就像一开始说的维护一个下对象分配起始位置的指针，操作这个指针完成内存分配，当ping的内存快要用完时，采用标注算法识别出存活的对象，并拷贝到pong区域中然后继续在pong部分中完成后续的内存分配，然后将ping区域中的垃圾进行回收清空，之后依次类推，就像打乒乓球一样。
这种算法的优点很明显，首先内存分配速度快，并且可以实现低中断，但是其缺点也显而易见，那就是在拷贝的过程中占用了额外的内存空间。这些可以在操作系统的虚拟内存提供的地址空间申请实现优化，所以这种算法在一些JVM实现中被广泛应用。
逐代回收算法（Generational GC）
Android Dalvik Heap将堆内存空间划分为三个不同的区域称为对象池，分别为young generation，old generation，permanent generation引入这种方式的原因主要是为了解决标注法中断时间过长，此优化主要是基于如下几个发现：
·大部分对象创建完成后就没用变成垃圾；
·GC过程中收集的对象大部分都是上次GC后创建的，也就是说垃圾进程被反复的创建
·鉴于以上特性可以发现当对象活过一个GC周期后他变成垃圾的概率便非常小因此对其进行反复的标注是浪费时间。
所以可以将逐代回收算法看做是拷贝GC算法的一个扩展一开始在young generation中完成内存的分配请求，当内存即将饱和执行GC标注清理法，存活的对象会移动到old generation当中同样的方式，当old generation快被填满时虚拟机再次执行GC并将存活对象转移至permanent generation。后面新创建的对象仍然在young generation中创建。由于young generation中回收的过程很快，只有少量进程可以存活相反old generation的GC执行不频繁，permanent generation GC执行更少，所以这就实现了很好的平衡。保证了GC执行的高效化。
 
图3-1  根据不同内存数据类型执行不同GC操作
4．内存泄漏（OOM）
Android 中有 Native Heap 和 Dalvik Heap。Android 的 Native Heap 言理论上可分配的空间取决了硬件 RAM，而对于每个进程的 Dalvik Heap 都是有大小限制的，如果应用的内存空间已经接近这个阈值，此时如果再次尝试分配内存的话很容易导致OOM，当然这个阈值也会在不同的设备上因为RAM的大小不同而不同。所以OOM本质实际上就是申请的内存超过了Dalvik Heap的最大值。
内存抖动
内存泄露的一个典型例子就是内存抖动，内存抖动的主要原因是因为内存频繁的分配和释放，这种频繁的GC不仅会导致卡顿，严重时会发生内存泄漏，究其原因还是因为大量的小的对象被频繁的创建，导致出现了内存碎片，从而即便是分配的内存仍然有剩余但是由于这些内存并非连续的所以分配失败导致内存泄漏。
内存泄漏的避免
	经过以上的理解认识到要想避免OOM最重要的一点就是减少进程对象的内存占用，这其中包含使用更加轻量级的数据结构，减少Bitmap的内存占用，还有内存对象的复用，这包括对Android系统自带资源的复用，还主要使用到了对象池技术，在安卓上面最常用的是LRU算法来维护缓存，同样当在一个显示大量图片的控件中，也需要用LRU缓存处理好的Bitmap，以保证内存的利用。同时，在代码实现大量字符串拼接操作时，可以考虑使用StringBuilder来替换“+”，最后尽量不要使用静态变量，因为静态变量会一直占用内存，不会被回收。
5. 位图与优化（Bitmap）
	位图就是指在APP上的大量图片的美化来增加更好的用户体验，这里位图以位图对象来存放在Native Heap中，这时Bitmap的占内存量仅与图像的长宽像素数有关，与原图片的图片格式或压缩比例无关，因此压缩图片质量而不是减少图片尺寸是无法降低该图像所占的内存的。由此引入位图的计算公式：图片长度x图片宽度x一个像素点占用的字节数。
	相比于其他对内存占用，位图可以说是一个大胖子，而且根据Android SDK文档可知Bitmap对象的数据是存放在Native Heap中，这一部分空间是与其他应用程序共享的，所以当考虑性能优化时首先就要考虑如何更好的减少位图的占用空间。
	探究高效加载Bitmap之前，研究了一下如何加载一个Bitmap总结出来加载Bitmap的四种方法分别是decodeFile，decodeResource，decodeStream和decodeByteArray分别用于从文件系统，资源，输入流以及字节数组中加载出一个Bitmap对象，其中使用decodeResource()图片实际上默认情况下是会进行缩放的，在解析时会对根据当前屏幕的Dpi值进行缩放适配操作，使Bitmap与当前设备分辨率相匹配。
	当需要高效加载Bitmap时就需要采用BitmapFactory.Options来加载所需尺寸的图片。这主要是用到了它的inSampleSize参数称为采样率，当inSampleSize()为1时，采样后的图片大小为图片的原始大小，当inSampleSize大于1时，例如2，采样后图片W/L均为原图大小的1/2，像素数即为原图的1/4，故根据计算公式，其占用的内存也为原图大小的1/4，可以发现其缩放比例为原图的1/SamplesSize()的平方。当然inSampleSize必须是大于1的整数，且应该总是2的指数，倘若传入值不为2的指数则系统会选择一个接近值进行替换。同时还可以使用inJustDecodeBounds参数设为true并加载图片。
以上便是我对安卓内存占用的几个方面的研究，有些地方没有研究清楚还望指出
